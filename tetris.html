<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>俄罗斯方块 - Microanswer</title>
    <style>
        *{
        -webkit-touch-callout:none; /系统默认菜单被禁用/
        -webkit-user-select:none; /webkit浏览器/
        -moz-user-select:none;/火狐/
        -ms-user-select:none; /IE10/
        user-select:none;
        }

        html, body {
            margin: 0;
            padding: 0;
        }

        .game-shell {
            border-radius: 10px;
            max-width: 375px;
            overflow: hidden;
            margin: 0 auto;
            background-color: #4fb1e6;
            /*box-shadow: 0 1px 6px gray;*/
        }
        .none {
            opacity: 0 !important;
        }

        .screen-top-inset,
        .screen-bottom-inset{
            position: relative;
            height: 60px;
        }

        .screen-bottom-inset {
            margin-top: 40px;
            margin-bottom: 30px;
        }
        .screen-bottom-inset::before {
            position: absolute;
            content: ' ';
            width: 50px;
            height: 50px;
            background-color: white;
            border-radius: 99999px;

            left: -25px;
        }
        .screen-bottom-inset::after {
            position: absolute;
            content: ' ';
            width: 50px;
            height: 50px;
            background-color: white;
            border-radius: 99999px;

            right: -25px;
        }

        .controller {
            display: flex;
            display: -webkit-flex;

            justify-content: space-around;
            -webkit-justify-content: space-around;
        }

        button {
            border-radius: 99999px;
            border: solid 1px #dab700;
            background-color: #e2be00;
            box-shadow: 0 0 4px 2px gray;
            outline: none;
            cursor: pointer;
        }

        button.sm {width: 25px;height: 25px;}
        button.md {width: 45px;height: 45px;}
        button.lg {width: 65px;height: 65px;}

        .controller .wasd,
        .controller .turn{
            text-align: center;
        }
    </style>
</head>
<body ondragstart="return false" oncontextmenu="return false" onselectstart="return false">
<div class="game-shell">

    <div class="screen-top-inset"></div>

    <div id="screen" style="margin: 0 auto"></div>

    <div class="screen-bottom-inset"></div>

    <div class="controller">
        <!-- 方向键 -->
        <div class="wasd">
            <div class="lr">
                <button class="md" id="left" title="左"></button>
                <button class="md none"></button>
                <button class="md" id="right" title="右"></button>
            </div>
            <div class="d" style="margin-top: 10px">
                <button class="md" id="down" title="下"></button>
            </div>
        </div>

        <!-- 变型键 -->
        <div class="turn">
            <button class="lg" id="change2" title="旋转"></button>
        </div>
    </div>
    <div class="controller" style="margin-top: 35px">
        <div>
            <button class="sm" id="start" title="开始"></button>&nbsp;&nbsp;&nbsp;
            <button class="sm" id="pause" title="暂停"></button>&nbsp;&nbsp;&nbsp;
            <button class="sm" id="reset" title="复位"></button>
        </div>
    </div>
    <div class="controller" style="font-size: 11px;color: white;">
        <div>
            <span>开始</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <span>暂停</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <span>复位</span>
        </div>
    </div>

    <p style="color: white;font-size: 11px;margin: 25px 15px auto 15px">
        <b>玩法介绍：</b><br>
        1.点击[开始]按钮开始新游戏。<br>
        2.游戏过程可以点击[暂停]。<br>
        3.[复位]按钮可以重置游戏到初始状态。<br>
        4.如果你用电脑，可以使用方向键来控制。<br>
        [W、↑]变型，[S、↓]下降，[A、←]左，[D、→]右
    </p>
    <p style="color: white;font-size: 11px;margin: 12px 15px">
        <b>关于：</b><br>
        作者:Microanswer<br>
        首页:<a target="_blank" href="https://www.microanswer.cn">www.microanswer.cn</a><br>
        源码:<a target="_blank" href="https://www.microanswer.cn/blog/68">查看源码</a><br>
        <script type="text/javascript">
            var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
            document.write(unescape("%3Cspan style='vertical-align:middle' id='cnzz_stat_icon_1263962182'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1263962182%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script>
    </p>


</div>

<script>

    /* 俄罗斯方块游戏 */
    (function (domId) {

        /* 定义了可用的材料， 这里面为了保证每个材料机会相同，有可能出现重复的 */
        var STUFS = [
            [[0, 0, 0, 0], /* 长条 */
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 长条 */
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0]],

            [[0, 1, 0, 0], /* 长条 */
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0]],

            [[0, 1, 0, 0], /* 长条 */
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0]],

            [[0, 0, 0, 0], /* 四块 */
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 四块 */
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 四块 */
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 四块 */
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 翻7 */
                [0, 1, 0, 0],
                [0, 1, 1, 1],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 翻7 */
                [0, 1, 1, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0]],

            [[0, 0, 0, 0], /* 翻7 */
                [0, 1, 1, 1],
                [0, 0, 0, 1],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 翻7 */
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 1, 1, 0]],

            [[0, 0, 0, 0], /* 正7 */
                [0, 1, 1, 1],
                [0, 1, 0, 0],
                [0, 0, 0, 0]],


            [[0, 0, 0, 0], /* 正7 */
                [0, 1, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0]],

            [[0, 0, 0, 0], /* 正7 */
                [0, 0, 0, 1],
                [0, 1, 1, 1],
                [0, 0, 0, 0]],

            [[0, 1, 0, 0], /* 正7 */
                [0, 1, 0, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 土 */
                [0, 1, 1, 1],
                [0, 0, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 土 */
                [0, 0, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 1, 0]],

            [[0, 0, 0, 0], /* 土 */
                [0, 0, 1, 0],
                [0, 1, 1, 1],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 土 */
                [0, 0, 1, 0],
                [0, 0, 1, 1],
                [0, 0, 1, 0]],

            [[0, 0, 0, 0], /* z */
                [0, 1, 1, 0],
                [0, 0, 1, 1],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* z */
                [0, 1, 1, 0],
                [0, 0, 1, 1],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* z */
                [0, 0, 1, 0],
                [0, 1, 1, 0],
                [0, 1, 0, 0]],

            [[0, 0, 0, 0], /* z */
                [0, 0, 1, 0],
                [0, 1, 1, 0],
                [0, 1, 0, 0]],

            [[0, 0, 0, 0], /* 翻z */
                [0, 0, 1, 1],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 翻z */
                [0, 0, 1, 1],
                [0, 1, 1, 0],
                [0, 0, 0, 0]],

            [[0, 0, 0, 0], /* 翻z */
                [0, 1, 0, 0],
                [0, 1, 1, 0],
                [0, 0, 1, 0]],

            [[0, 0, 0, 0], /* 翻z */
                [0, 1, 0, 0],
                [0, 1, 1, 0],
                [0, 0, 1, 0]]
        ];

        /* 定义了各个等级下降的速度， 实际上数字用于settimeout时间间隔 */
        var LEVELS = [800, 700, 600, 500, 400, 300, 200, 100, 90, 50];
        /* 成绩对应等级 */
        var SCORE_LEVELS = {
            "50": 1,
            "100": 2,
            "150": 3,
            "200": 4,
            "250": 5,
            "300": 6,
            "350": 7,
            "400": 8,
            "450": 9
        };
        /* 急速模式的时间间隔 */
        var TURBO_TIME_SPACE = 5;
        /* 材料每次开始下落时将使用此数字从左到右指定点阵个数的偏移量向下掉落 */
        var STUFF_START_X_OFFSET = 3;
        var STUFF_START_Y_OFFSET = -3;

        var gameWidth       = 160;       /* 游戏视窗宽度 */
        var gameHeight      = 215;       /* 游戏视窗高度 */
        var gameDom         = null;      /* 游戏dom容器 */
        var gameCanvas      = null;      /* 游戏画板 */
        var splitPosition   = 110;      /* 左边面板和右边面板的分割点，数值以从左到右计算。 */
        var drawColor1      = '#010700'; /* 画笔浓颜色 */
        var drawColor2      = '#ccebce'; /* 画笔浅颜色 */
        var lineWidth       = 1;         /* 画笔粗细 */
        var fontSize        = 13;        /* 文字大小 */
        var fontSpace       = 13;        /* 文字行间距 */

        var atomwidthCount  = 10;        /* 游戏区域，横向的点阵个数 */
        var atomheightCount = 20;        /* 游戏区域，竖向的点阵个数 */
        var atomWidth       = null;      /* 单个点阵宽度 */
        var atomHeight      = null;      /* 单个点阵高度 */
        var atomSpace       = 2.5;       /* 点阵间隙大小 */
        var atomBorder      = 1.5;       /* 点阵外轮廓粗细 */
        var atomInset       = 0.5;       /* 点阵中间的间隙大小 */

        var currStuff       = null;      /* 当前正在下落的材料 */
        var stuffOffsetX    = STUFF_START_X_OFFSET; /* 材料每次开始下落时将使用此数字从左到右指定点阵个数的偏移量向下掉落 */
        var stuffOffsetY    = STUFF_START_Y_OFFSET; /* 材料每次开始下落时将使用此数字从上到下指定某个点阵数偏移量向下掉落 */
        var nextStuff       = null;      /* 下一个要降落的材料方块 */
        var gameAtoms       = null;      /* array。整个游戏操作面板，本质上是在操作此数组。 */
        var staticStuffs    = null;      /* array。已被确认堆砌的材料将在这个数组里保存。*/

        var resetAtoms      = null;      /* array。重置动画将使用此变量保存所有点阵信息 */
        var turbo           = false;     /* 为true则是急速模式，此模式下材料下降很快 */
        var succAniming     = false;     /* 当有成功的行在进行消除动画时，此字段将为true，通过此字段控制正在消除动画时是否降落新材料。 */
        var gameover        = true;      /* 标记游戏是否结束 */
        var pause           = false;     /*标记是否暂停*/

        var bestscore       = 0;         /* 最佳成绩·本地保存 */
        var score           = 0;         /* 游戏成绩 */
        var level           = 0;         /* 当前游戏等级 */

        /* 初始化游戏根容器方法 */
        function initGameDom (domId) {
            var gameDom = document.querySelector("#" + domId);
            gameDom.style.width = gameWidth + "px";
            gameDom.style.height = gameHeight + "px";
            gameDom.style.border = "1px solid gray";
            gameDom.style.backgroundColor = "#dbffdd";

            return gameDom;
        }

        /* 初始化画板 */
        function initGameCanvas (gameDom) {
            var canvasDom = document.createElement("canvas");
            canvasDom.width = gameWidth;
            canvasDom.height = gameHeight;
            gameDom.appendChild(canvasDom);

            var canvas    = canvasDom.getContext("2d");
            canvas.width  = gameWidth;
            canvas.height = gameHeight;
            canvas.canvas.width  = gameWidth;
            canvas.canvas.height = gameHeight;


            return canvas;
        }

        /* 初始化一些游戏逻辑参数值 */
        function initLogic () {
            /* 根据 splitPosition 计算出点阵大小数值 */
            var gameAreaWidth = splitPosition - lineWidth;
            gameAreaWidth = gameAreaWidth - (atomSpace * (atomwidthCount + 1));
            atomWidth = gameAreaWidth / atomwidthCount;

            var gameAreaHeight = gameHeight;
            gameAreaHeight = gameAreaHeight - (atomSpace * (atomheightCount + 1));
            atomHeight = gameAreaHeight / atomheightCount;

            /* 最高成绩 */
            bestscore = window.localStorage && window.localStorage.getItem("bestscore") || 0;

            /* 键盘点击 */
            document.onkeydown = function (ev) {
                var f = {
                    /* w上  */"87": function () {
                        rotateStuff();
                    },
                    /* 上  */"38": function () {
                        rotateStuff();
                    },
                    /* s下  */"83": function () {
                        turboModeON();
                    },
                    /* 下  */"40": function () {
                        turboModeON();
                    },
                    /* a左  */"65": function () {
                        left();
                    },
                    /* 左  */"37": function () {
                        left();
                    },
                    /* d右  */"68": function () {
                        right();
                    },
                    /* 右  */"39": function () {
                        right();
                    },
                    /* 空格  */"32": function () {
                        rotateStuff();
                    },
                }[String(ev.keyCode)];
                if (f) {
                    ev.stopPropagation();
                    f();
                }
            };
            document.onkeyup = function (ev) {
                var f = {
                    /* s下  */"83": function () {
                        turboModeOFF();
                    },
                    /* 下  */"40": function () {
                        turboModeOFF();
                    }
                }[String(ev.keyCode)];
                if (f) {
                    ev.stopPropagation();
                    f();
                }
            };
        }

        /* 此方法将随机产生一个用于游戏的堆砌材料 */
        function randomStuff () {
            var index = Math.floor(Math.random() * STUFS.length);
            return [].concat(STUFS[index]);
        }

        /* 此方法将执行一次"重置动画效果"。效果就是从下到上渲染点阵，然后从上到下撤销渲染点阵。 */
        /* cb 当从下到上渲染完成了所有的点阵后，执行。这时候正是满屏都是点阵，看不到任何其他操作，所以 */
        /* 很方便在此时进行一些新任务的初始化。 */
        function resetAnim (cb) {
            scroll(atomheightCount, 0, {
                goo: function (value) {
                    if (!resetAtoms) {resetAtoms = new Array(atomheightCount);}
                    for (var i = value; i < atomheightCount; i++) {
                        resetAtoms[i] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
                    }
                },
                end: function (end) {
                    for (var i = 0; i < atomheightCount - 1; i++) {
                        resetAtoms[i] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
                    }
                    cb && cb();

                    setTimeout(function () {
                        scroll(0, atomheightCount - 1, {
                            goo: function (val) {
                                for (var i = 0; i < val; i++) {
                                    resetAtoms[i] = undefined;
                                }
                            },
                            end: function (end) {
                                resetAtoms = null;
                            }
                        });
                    }, 100);
                }
            })
        }

        /*暂停游戏，再次调用则恢复*/
        function pauseGame () {
            if (!gameover && gameAtoms && staticStuffs) {
                pause = !pause;
            }
        }

        /*开启急速模式，急速模式下落完成一个材料后自动关闭，也可以手动调用 turboModeOFF 方法关闭，*/
        function turboModeON() {
            if (gameAtoms && currStuff) {
                turbo = true;
            }
        }

        /* 关闭急速模式 */
        function turboModeOFF() {
            turbo = false;
        }

        /* 旋转材料。 此方法只有在游戏中有效，可以将正在下落的材料进行顺时针90度旋转。 */
        function rotateStuff () {
            if (gameAtoms && currStuff) {
                var temp = [
                    [],
                    [],
                    [],
                    []
                ];

                // 进行旋转材料
                for (var i = 0; i < currStuff.length; i++) {
                    for (var j = 0; j < currStuff[i].length; j++) {

                        var ni = j;
                        var nj = currStuff.length - 1 - i;
                        temp[ni][nj] = currStuff[i][j];

                        if (stuffOffsetY + ni < 0) {
                            /* 材料还没下降到屏幕内 */
                            continue;
                        }

                        if (stuffOffsetY + ni >= atomheightCount) {
                            /*变化会超出屏幕，不准变*/
                            return;
                        }

                        if (stuffOffsetX + nj >= atomwidthCount || stuffOffsetX + nj < 0) {
                            return;
                        }


                        /*判断变化后的材料是否和已确定的堆砌产生重叠，产生了则不进行此次变化*/
                        if (staticStuffs[stuffOffsetY + ni][stuffOffsetX + nj] === 1) {
                            return;
                        }
                    }
                }

                /* 变化了之后，重新赋值数组，让界面变化。 */
                currStuff = temp;
                for (i = 0; i < staticStuffs.length; i++) {
                    for (j = 0; j < staticStuffs[j].length; j++) {
                        gameAtoms[i][j] = staticStuffs[i][j];
                    }
                }
                for (i = 0; i < currStuff.length; i++) {
                    for (j = 0; j < currStuff[i].length; j++) {
                        if (stuffOffsetY + i < 0 || stuffOffsetX + j < 0 || stuffOffsetY + i >= atomheightCount) {
                            continue;
                        }

                        if (
                            gameAtoms[stuffOffsetY + i][stuffOffsetX + j] === 0 &&
                            currStuff[i][j] === 1
                        ) {
                            gameAtoms[stuffOffsetY + i][stuffOffsetX + j] = currStuff[i][j];
                        }
                    }
                }
            }
        }

        /* 将材料向左边移动一格 */
        function left () {
            _moveCurrStuff(-1);
        }
        /* 将材料向右边移动一格 */
        function right () {
            _moveCurrStuff(1);
        }

        /* 重置游戏 */
        function _resetGame () {
            gameover     = true;
            gameAtoms    = null;
            staticStuffs = null;
            currStuff    = null;
            nextStuff    = null;
            succAniming  = false;
            turbo        = false;
            score        = 0;
            level        = 0;
            stuffOffsetX = STUFF_START_X_OFFSET;
            stuffOffsetY = STUFF_START_Y_OFFSET;
        }

        /* 移动当前正在掉落的材料。 count 为移动几格，负数则是左移 */
        function _moveCurrStuff (count) {
            if (gameAtoms && currStuff && staticStuffs) {
                var targetOffsetX = stuffOffsetX + count;

                for (var i = 0; i < currStuff.length; i++) {
                    for (var j = 0; j < currStuff[i].length; j++) {
                        if (currStuff[i][j] === 1) {
                            if (targetOffsetX + j < 0) {
                                /* 传入的目标位数会导致移动到屏幕左边的外面。则强制让其在屏幕内。 */
                                targetOffsetX = -j;
                            } else if (targetOffsetX + j > atomwidthCount - 1) {
                                /* 传入的目标位数会导致移动到屏幕右边的外面。则强制让其在屏幕内。 */
                                targetOffsetX = atomwidthCount - j - 1;
                            }

                            /* 材料还没完全下降到屏幕内 */
                            if (stuffOffsetY + i < 0) continue;

                            /* 判断新位置上是否有材料了，有就不能进行移动 */
                            if (staticStuffs[stuffOffsetY + i][targetOffsetX + j] === 1) {
                                return;
                            }
                        }
                    }
                }



                for (i = 0; i < staticStuffs.length; i++) {
                    for (j = 0; j < staticStuffs[j].length; j++) {
                        gameAtoms[i][j] = staticStuffs[i][j];
                    }
                }

                // 根据新的 offset ，进行对 gameAtoms 整列重新赋值。
                for (i = 0; i < currStuff.length; i++) {
                    for (j = 0; j < currStuff[i].length; j++) {
                        if (stuffOffsetY + i < 0 || targetOffsetX + j < 0 || stuffOffsetY + i >= atomheightCount) {
                            continue;
                        }

                        if (
                            gameAtoms[stuffOffsetY + i][targetOffsetX + j] === 0 &&
                            currStuff[i][j] === 1
                        ) {
                            gameAtoms[stuffOffsetY + i][targetOffsetX + j] = currStuff[i][j];
                        }
                    }
                }

                stuffOffsetX = targetOffsetX;
            }
        }

        /*游戏结束时执行*/
        function resetGame () {
            if (gameover) {
                return;
            }

            gameover = true;

            /* 保存最佳成绩。*/
            if (score > bestscore) {
                bestscore = score;
                window.localStorage && window.localStorage.setItem("bestscore", bestscore);
            }

            resetAnim(function () {
                _resetGame();
            });
        }

        /*检查堆砌成功的行，并进行消除*/
        function checkSuccessLine() {

            var successLine = [];

            for (var i = 0; i < staticStuffs.length; i++) {

                var isSuccess = true;
                for (var j = 0; j < staticStuffs[i].length; j++) {
                    if (staticStuffs[i][j] !== 1){
                        isSuccess = false;
                        break;
                    }
                }


                /* 成功一行就+1分*/
                if (isSuccess) {
                    succAniming = true;
                    score += 1;
                    successLine.push(i);

                    /*提升等级*/
                    var newLevel = SCORE_LEVELS[String(score)];
                    if (newLevel > level) {
                        level = newLevel;
                    }
                }
            }


            var ended = false;
            var onAnimEnd = function () {
                if (ended) {
                    return;
                }
                ended = true;

                setTimeout(function () {
                    /*动画完成后重整数组，将消除的行上面的依次向下整理*/
                    while (successLine.length > 0) {
                        var rowm = successLine.shift();
                        eachNum(rowm, 1, function (row) {
                            var lastRow = row - 1;

                            if (lastRow === 0) {
                                staticStuffs[row] = [0,0,0,0,0,0,0,0,0,0];
                            } else {
                                staticStuffs[row] = [].concat(staticStuffs[lastRow]);
                            }
                        });
                    }
                    succAniming = false;
                    gameAtoms = arrCopy(staticStuffs);
                }, 50);
            };

            /* 在数组里将消除的行全部置为0，通过此操作使得界面上的行有个从左到右消减的动画 */
            each(successLine, function (index, value) {
                scroll(0, gameAtoms[value].length - 1, {
                    goo: function (process) {
                        var l = gameAtoms[value].length;
                        /*scroll方法有bug吗，process应该在to范围内啊，但是出现了超过to的现象，所以这里判断一下*/
                        process = process >= l ? l : process;
                        for (var j = 0; j < process; j++) {
                            gameAtoms[value][j] = 0;
                        }
                    },
                    end: function (end) {
                        for (var j = 0; j < gameAtoms[value].length; j++) {
                            gameAtoms[value][j] = 0;
                        }

                        /* 将消除的行剩下的重整 */
                        onAnimEnd();
                    }
                }, 200);
            });
        }

        /* 将 currStuff 材料通过指定的横向偏移量 stuffOffsetX 进行融合，并将 stuffOffsetY 下降1格。*/
        /* 如果 currStuff 材料已经到达了 gameAtoms 底部或已有材料的底部将返回 true */
        function _GameArrMerge (stuffOffsetX, mStuffOffsetY, currStuff, mGameAtoms, mStaticStuffs) {

            var grounded = false;

            w:for (var i = currStuff.length - 1; i >= 0 ; i--) {
                for (var j = currStuff[i].length - 1; j >= 0; j--) {
                    if (currStuff[i][j] !== 1) continue;

                    /* 判断此元素下降一格后是否触底 */
                    var c_stuffOffsetY = mStuffOffsetY + i;

                    if (c_stuffOffsetY < 0) continue;
                    var c_stuffOffsetX = stuffOffsetX + j;
                    if (c_stuffOffsetX < 0) continue;
                    if (c_stuffOffsetY === atomheightCount - 1 || mStaticStuffs[c_stuffOffsetY + 1][c_stuffOffsetX] === 1) {
                        grounded = true;
                        break w;
                    }
                }
            }

            /* 将 currStuff 融合到 mGameAtoms 里面 */
            if (!grounded) {
                mStuffOffsetY = stuffOffsetY = mStuffOffsetY + 1;

                mGameAtoms = gameAtoms = arrCopy(mStaticStuffs);

                for (i = 0; i < currStuff.length; i++) {
                    for (j = 0; j < currStuff[i].length; j++) {
                        if (mStuffOffsetY + i < 0 || stuffOffsetX + j < 0 || mStuffOffsetY + i >= atomheightCount) {
                            continue;
                        }

                        if (
                            mGameAtoms[mStuffOffsetY + i][stuffOffsetX + j] === 0 &&
                            currStuff[i][j] === 1
                        ) {
                            mGameAtoms[mStuffOffsetY + i][stuffOffsetX + j] = currStuff[i][j];
                        }
                    }
                }
            }

            /* 如果触底了，则将 mGameAtoms 保存一份为 mStaticStuffs */
            if (grounded) {
                staticStuffs = arrCopy(mGameAtoms);
            }


            return grounded;
        }

        /* 调用此方法开始游戏。 如果在游戏进行中重复调用了此方法，将忽略。 */
        function startGame () {

            /* 一旦此数组有值，则认为在游戏中，直接不处理。 */
            if (!gameover) {
                return;
            }
            gameover = false;

            /* 初始化游戏数组为一个空数组 */
            gameAtoms = [];
            staticStuffs = [];
            for (var j = 0; j < atomheightCount; j++) {
                gameAtoms[j] = [];
                staticStuffs[j] = [];
                for (var i = 0; i < atomwidthCount; i++) {
                    gameAtoms[j][i] = 0;
                    staticStuffs[j][i] = 0;
                }
            }

            var lastTime = 0;
            (function loop() {

                if (
                    (!pause) &&
                    (!gameover /* 游戏未标记为结束 */) &&
                    (!succAniming/*在消减动画时不执行下落*/) &&
                    Date.now() - lastTime >= (turbo ? TURBO_TIME_SPACE : LEVELS[level])
                ) {

                    var isNewCurrStuf = false;

                    if (!currStuff) {
                        currStuff = nextStuff; /* 始终优先从下一个材料获取 */
                        nextStuff = null;
                        isNewCurrStuf = !!currStuff;
                    }
                    if (!currStuff) {
                        currStuff = randomStuff(); /* 通过下一个材料也没能获取到材料，说明这是游戏刚开始，此处可以直接随机获取一个。 */
                        nextStuff = null;
                        isNewCurrStuf = !!currStuff;
                    }
                    if (!nextStuff) {
                        nextStuff = randomStuff(); /* 产生下一个新材料 */
                        isNewCurrStuf = !!currStuff;
                    }

                    if (isNewCurrStuf) {
                        turboModeOFF(); /*新材料掉下来时关闭急速模式*/
                    }

                    /* 将 当前掉落 的材料通过指定的横向偏移量进行融合，并将 currStuff 下降1格。 */
                    var grounded = _GameArrMerge(stuffOffsetX, stuffOffsetY, currStuff, gameAtoms, staticStuffs);
                    if (grounded) {
                        /* 掉落到了能够掉落的最底部了，可以进行下一个材料的掉落了。 */
                        currStuff = null;
                        stuffOffsetX = STUFF_START_X_OFFSET;
                        stuffOffsetY = STUFF_START_Y_OFFSET;

                        /* 检查堆砌成功了的 */
                        checkSuccessLine();

                        /*检查是否触顶*/
                        for (var i = 0; i < staticStuffs[0].length; i++) {
                            if (staticStuffs[0][i] === 1) {
                                /* 最顶部只要有一块材料，就认为游戏结束 */
                                resetGame();
                                return;
                            }
                        }
                    }
                    lastTime = Date.now();
                }
                if (!gameover) {
                    setTimeout(loop, 5);
                }
            })();
        }

        function printArr (arr) {
            var s="";
            each(arr, function (i, arrr) {
                s+=(i+":"+arrr.join(" "))+"\n";
            });
            console.log(s);
        }
        function arrCopy (src) {
            var temp = [];
            for (var i = 0; i < src.length; i++) {
                temp[i] = [];
                for (var j = 0; j < src[j].length; j++) {
                    temp[i][j] = src[i][j];
                }
            }
            return temp;
        }
        function eachNum(from, to, fun) {
            if (from > to) {

                for (var i = from; i >= to ; i--) {
                    fun && fun(i);
                }

                return;
            }
            for (var i = from; i <= to; i++) {
                fun && fun(i);
            }
        }
        function each(arr, fun) {
            for (var i = 0; i < arr.length; i++) {
                fun && fun(i, arr[i]);
            }
        }

        /**
         * 滚动。 此方法并不滚动界面，而是将一个数值变化到另一个数值。
         * @param from 从某个值
         * @param to 到某个值
         * @param back 不停的回调
         * @param dur 动画执行时长，默认 500 毫秒
         */
        function scroll (from, to, back, dur) {
            var y = from;
            y = y || 0;
            var startY = y;

            var distanceY = to - startY;

            if (distanceY === 0) {
                // 没有意义的滚动
                back && back.end && back.end(to);
                return undefined
            }

            var ended = false;
            var time = dur || 500;
            var ftp = 60;
            var ease = function (pos) {
                // return -(Math.pow((pos - 1), 4) - 1);
                return pos;
            }; // 要使用的缓动公式
            var startTime = new Date().getTime(); // 开始时间
            // 开始执行
            (function dd () {
                setTimeout(function () {
                    var now = new Date().getTime(); // 当前帧开始时间
                    var timestamp = now - startTime; // 逝去的时间(已进行动画的时间)
                    var detal2 = ease(timestamp / time);
                    var result2 = Math.ceil(startY + detal2 * distanceY);
                    if (!ended) {
                        back && back.goo && back.goo(result2);
                    }
                    if (time <= timestamp) {
                        ended = true;
                        back.end(to);
                    } else {
                        setTimeout(dd, 1000 / ftp);
                    }
                }, 1000 / ftp);
            })();
        }

        /* x 所有点阵起始计算横坐标点 */
        /* y 所有点阵起始计算竖坐标点 */
        /* 绘制一个点阵，通过 2 个下标确定绘制具体哪一个点阵 */
        /* 下标的数值规则是：从左上角到右上交 widthIndex 1~10 */
        /* 从左上角到左下交 heightIndex 1~20 */
        /* c 绘制颜色 */
        function renderAtom (startX, startY, widthIndex, heightIndex, ctx, c) {
            var x = startX + (widthIndex * (atomSpace + atomWidth)) - atomWidth;
            var y = startY + (heightIndex * (atomSpace + atomHeight)) - atomHeight;

            var osc = ctx.strokeStyle;
            var osw = ctx.lineWidth;
            var ofc = ctx.fillStyle;
            ctx.strokeStyle = c;
            ctx.fillStyle = c;
            ctx.lineWidth = atomBorder;
            ctx.beginPath();
            ctx.rect(x, y, atomWidth, atomHeight);
            ctx.stroke();

            ctx.fillRect(x + atomBorder + atomInset, y+atomBorder+atomInset, atomWidth-(2*atomBorder)-(2*atomInset), atomHeight-(2*atomBorder)-(2*atomInset));

            ctx.strokeStyle = osc;
            ctx.lineWidth = osw;
            ctx.fillStyle = ofc;
        }

        /* 绘制左边游戏面板 */
        function renderLeft (ctx) {
            /* 先绘制点阵背景 */
            for (var i = 1; i <= atomwidthCount; i++) {
                for (var j = 1; j <= atomheightCount; j++) {
                    renderAtom(0, 0, i,j, ctx, drawColor2);
                }
            }

            /* 绘制游戏数组 */
            if (gameAtoms) {
                for (i = 0; i < gameAtoms.length; i++) {
                    for (j = 0; j < gameAtoms[i].length; j++) {
                        if (gameAtoms[i][j] === 1) {
                            renderAtom(0, 0, j + 1, i + 1, ctx, drawColor1);
                        }
                    }
                }
            }


            /* 绘制重置动画 */
            if (resetAtoms) {
                for (i = resetAtoms.length - 1; i >= 0; i--) {
                    if (resetAtoms[i]) {
                        for (j = resetAtoms[i].length - 1; j >= 0 ; j--) {
                            if (resetAtoms[i][j] === 1) {
                                renderAtom(0, 0, j+1, i+1, ctx, drawColor1);
                            }
                        }
                    }
                }
            }
        }

        /* 绘制右边 下一个方块，游戏成绩 */
        function renderRight (ctx) {

            /* 绘制游戏成绩 */
            var yOffset = fontSize;
            ctx.font = "italic normal normal " + fontSize + "px arial";
            ctx.fillText("Score", splitPosition + atomSpace, yOffset);
            ctx.font = "normal normal bold " + fontSize + "px arial";
            yOffset = yOffset + fontSize;
            ctx.fillText(String(score), splitPosition + atomSpace, yOffset);

            ctx.font = "italic normal normal " + fontSize + "px arial";
            yOffset = yOffset + fontSize + fontSpace;
            ctx.fillText("Next", splitPosition + atomSpace, yOffset);
            /* 绘制接下来要使用的材料。 */
            for (var i = 1; i <= 4; i++) {
                for (var j = 1; j <= 4; j++) {
                    /* 绘制背景 */
                    renderAtom(splitPosition, yOffset, i, j, ctx, drawColor2);

                    /* 绘制预备材料 */
                    if (nextStuff) {
                        var ns = nextStuff[j - 1][i - 1];
                        if (ns === 1) {
                            renderAtom(splitPosition, yOffset, i, j, ctx, drawColor1);
                        }
                    }
                }
            }

            /* 绘制等级 */
            ctx.font = "italic normal normal " + fontSize + "px arial";
            yOffset = yOffset + fontSize + fontSpace + (4 * (atomHeight + atomSpace));
            ctx.fillText("Level", splitPosition + atomSpace, yOffset);
            ctx.font = "normal normal bold " + fontSize + "px arial";
            yOffset = yOffset + fontSize;
            ctx.fillText(String(level), splitPosition + atomSpace, yOffset);

            /* 绘制最佳成绩 */
            ctx.font = "italic normal normal " + fontSize + "px arial";
            yOffset = yOffset + fontSize + fontSpace;
            ctx.fillText("Best", splitPosition + atomSpace, yOffset);
            ctx.font = "normal normal bold " + fontSize + "px arial";
            yOffset = yOffset + fontSize;
            ctx.fillText(String(bestscore), splitPosition + atomSpace, yOffset);

            /* 绘制暂停提示 */
            if (pause) {
                ctx.font = "italic normal normal " + fontSize + "px arial";
                yOffset = yOffset + fontSize + fontSpace;
                ctx.fillText("Paused", splitPosition + atomSpace, yOffset);
            }
        }

        /* 此方法会被循环调用，用于绘制游戏内容 */
        function onRender (ctx) {
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            ctx.strokeStyle = drawColor1;
            ctx.fillStyle   = drawColor1;
            ctx.lineCap     = 'butt';
            ctx.lineWidth   = lineWidth;

            renderLeft(ctx);

            /* 绘制分割线 */
            ctx.beginPath();
            ctx.moveTo(splitPosition, 0);
            ctx.lineTo(splitPosition, gameHeight);
            ctx.stroke();
            ctx.closePath();

            renderRight(ctx);
        }

        /* 开始执行绘制 */
        function render (ctx) {
            (function loop () {
                onRender(ctx);
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(loop);
                } else if (window.webkitRequestAnimationFrame) {
                    window.webkitRequestAnimationFrame(loop);
                } else {
                    setTimeout(loop, 33);
                }
            })();
        }

        gameDom = initGameDom(domId);
        gameCanvas = initGameCanvas(gameDom);
        initLogic();
        render(gameCanvas);

        document.querySelector("#reset").addEventListener("click", function (evt) {
            resetGame();
        });
        document.querySelector("#start").addEventListener("click", function (evt) {
            startGame();
        });
        document.querySelector("#left").addEventListener("click", function (evt) {
            left();
        });
        document.querySelector("#right").addEventListener("click", function (evt) {
            right();
        });
        document.querySelector("#change2").addEventListener("click", function (evt) {
            rotateStuff();
        });
        var d = document.querySelector("#down");
        d.addEventListener("touchstart", function (evt) {
            turboModeON();
        });
        d.addEventListener("touchend", function (evt) {
            turboModeOFF();
        });
        d.addEventListener("mousedown", function (evt) {
            turboModeON();
        });
        d.addEventListener("mouseup", function (evt) {
            turboModeOFF();
        });
        document.querySelector("#pause").addEventListener("click", function (evt) {
            pauseGame();
        });


    })("screen");

</script>
</body>
</html>
